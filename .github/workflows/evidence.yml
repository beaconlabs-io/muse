name: Evidence Processing and Attestation

# TODO: fix target branch to main
on:
  pull_request:
    branches: [dev] # main
    paths: ["contents/evidence/**/*.mdx"]
    types: [opened, synchronize, reopened] # closed

# Add permissions configuration
permissions:
  contents: write
  pull-requests: write

jobs:
  detect-evidence-changes:
    runs-on: ubuntu-latest

    outputs:
      changed-evidence-paths: ${{ steps.evidence-paths.outputs.paths }}
      evidence-count: ${{ steps.evidence-paths.outputs.count }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get changed evidence files
        id: changed-files
        run: |
          echo "ðŸ” Detecting evidence changes in PR"

          # Ensure main branch is fetched
          echo "Fetching main branch..."
          git fetch origin main:main 2>/dev/null || echo "Could not fetch origin/main, using local main"

          # Try multiple methods to get diff (in order of priority)
          CHANGED_FILES=""

          echo "=== Method 1: Direct main comparison ==="
          if git show-ref --verify --quiet refs/heads/main; then
            ALL_CHANGED=$(git diff --name-only main 2>/dev/null || true)
            echo "All changed files:"
            echo "$ALL_CHANGED"
            CHANGED_FILES=$(echo "$ALL_CHANGED" | grep "contents/evidence/.*\.mdx$" || true)
            echo "Evidence files found:"
            echo "$CHANGED_FILES"
          else
            echo "Local main branch not found"
          fi

          # Fallback if Method 1 fails
          if [ -z "$CHANGED_FILES" ]; then
            echo "=== Method 2: Using origin/main ==="
            ALL_CHANGED=$(git diff --name-only origin/main 2>/dev/null || true)
            echo "All changed files:"
            echo "$ALL_CHANGED"
            CHANGED_FILES=$(echo "$ALL_CHANGED" | grep "contents/evidence/.*\.mdx$" || true)
            echo "Evidence files found:"
            echo "$CHANGED_FILES"
          fi

          # Final fallback if Method 2 also fails
          if [ -z "$CHANGED_FILES" ]; then
            echo "=== Method 3: Using HEAD~1 ==="
            ALL_CHANGED=$(git diff --name-only HEAD~1 2>/dev/null || true)
            echo "All changed files:"
            echo "$ALL_CHANGED"
            CHANGED_FILES=$(echo "$ALL_CHANGED" | grep "contents/evidence/.*\.mdx$" || true)
            echo "Evidence files found:"
            echo "$CHANGED_FILES"
          fi

          echo ""
          echo "Final result - Changed MDX files:"
          if [ -n "$CHANGED_FILES" ]; then
            echo "$CHANGED_FILES"
          else
            echo "(no evidence files changed)"
          fi

          # Set as GitHub Actions output
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Extract evidence paths
        id: evidence-paths
        run: |
          # Extract relative paths from changed files
          CHANGED_FILES="${{ steps.changed-files.outputs.files }}"
          EVIDENCE_PATHS=""
          COUNT=0

          if [ -n "$CHANGED_FILES" ]; then
            while IFS= read -r file; do
              if [ -n "$file" ]; then
                # Remove contents/evidence/ prefix to get relative path
                RELATIVE_PATH=$(echo "$file" | sed 's|^contents/evidence/||')
                
                if [ -n "$EVIDENCE_PATHS" ]; then
                  EVIDENCE_PATHS="$EVIDENCE_PATHS,$RELATIVE_PATH"
                else
                  EVIDENCE_PATHS="$RELATIVE_PATH"
                fi
                
                COUNT=$((COUNT + 1))
                echo "Found evidence path: $RELATIVE_PATH"
              fi
            done <<< "$CHANGED_FILES"
          fi

          echo "Evidence paths: $EVIDENCE_PATHS"
          echo "Total count: $COUNT"

          # Set as GitHub Actions output
          echo "paths=$EVIDENCE_PATHS" >> $GITHUB_OUTPUT
          echo "count=$COUNT" >> $GITHUB_OUTPUT

  upload-to-ipfs:
    runs-on: ubuntu-latest
    needs: detect-evidence-changes
    if: needs.detect-evidence-changes.outputs.evidence-count > 0

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20.x.x"
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: "10.x.x"
      - name: Install dependencies
        run: |
          pnpm install @ethereum-attestation-service/eas-sdk ethers dotenv gray-matter

      - name: Process and upload evidence files
        env:
          PINATA_JWT: ${{ secrets.PINATA_JWT }}
        run: |
          echo "ðŸ“¤ Processing and uploading evidence files to IPFS"
          echo "ðŸ”‘ Checking environment variables..."
          # Create results file to track uploads
          echo "[]" > ipfs-results.json

          EVIDENCE_PATHS="${{ needs.detect-evidence-changes.outputs.changed-evidence-paths }}"

          if [ -n "$EVIDENCE_PATHS" ]; then
            IFS=',' read -ra PATHS <<< "$EVIDENCE_PATHS"
            for relative_path in "${PATHS[@]}"; do
              if [ -n "$relative_path" ]; then
                full_path="contents/evidence/$relative_path"
                echo ""
                echo "ðŸ”„ Processing: $relative_path"
                
                if [ -f "$full_path" ]; then
                  # Extract content using Node.js script
                  node -e "
                    const fs = require('fs');
                    const matter = require('gray-matter');
                    const path = require('path');
                    
                    const filePath = '$full_path';
                    const relativePath = '$relative_path';
                    
                    try {
                      // Read the MDX file
                      const fileContent = fs.readFileSync(filePath, 'utf8');
                      
                      // Parse frontmatter and content
                      const { data: frontmatter, content } = matter(fileContent);
                      
                      console.log(\`ðŸ“„ File: \${relativePath}\`);
                      console.log(\`ðŸ“Š Content length: \${content.length} characters\`);
                      
                      // Save extracted content to temporary file
                      const tempFileName = path.basename(relativePath, '.mdx') + '_content.md';
                      fs.writeFileSync(\`temp_\${tempFileName}\`, content);
                      
                      console.log(\`âœ… Content extracted to temp_\${tempFileName}\`);
                      
                    } catch (error) {
                      console.error(\`âŒ Error processing \${filePath}:\`, error.message);
                      process.exit(1);
                    }
                  "
                  
                  # If content extraction was successful, upload to IPFS
                  if [ $? -eq 0 ]; then
                    temp_file="temp_$(basename "$relative_path" .mdx)_content.md"
                    
                    if [ -f "$temp_file" ]; then
                      echo "ðŸŒ Uploading to IPFS via Pinata..."
                      
                      # Use the Pinata upload script with explicit environment variable passing
                      PINATA_JWT="$PINATA_JWT" node -e "
                        const fs = require('fs');
                        const pinataUpload = require('./.github/scripts/pinata.js');
                        
                        const relativePath = '$relative_path';
                        const tempFile = '$temp_file';
                        
                        async function uploadFile() {
                          try {
                            // Verify environment variable is available in Node.js context  
                            if (!process.env.PINATA_JWT) {
                              throw new Error('PINATA_JWT environment variable is not available in Node.js context');
                            }
                            
                            // Read the extracted content
                            const content = fs.readFileSync(tempFile, 'utf8');
                            
                            // Generate filename for IPFS
                            const filename = 'evidence.md';
                            
                            console.log(\`ðŸ“¤ Uploading \${filename} to IPFS...\`);
                            console.log(\`ðŸ“Š Content size: \${content.length} characters\`);
                            
                            // Upload to IPFS
                            const result = await pinataUpload({
                              text: content,
                              filename: filename
                            });
                            
                            console.log(\`âœ… Upload successful!\`);
                            console.log(\`ðŸ“ IPFS Hash: \${result.hash}\`);
                            console.log(\`ðŸ“ Size: \${result.size} bytes\`);
                            
                            // Save result to JSON file
                            const resultData = {
                              relativePath: relativePath,
                              filename: filename,
                              ipfsHash: result.hash,
                              size: result.size,
                              timestamp: result.timestamp,
                              uploadedAt: new Date().toISOString()
                            };
                            
                            // Read existing results
                            let results = [];
                            try {
                              results = JSON.parse(fs.readFileSync('ipfs-results.json', 'utf8'));
                            } catch (e) {
                              results = [];
                            }
                            
                            // Add new result
                            results.push(resultData);
                            
                            // Write back to file
                            fs.writeFileSync('ipfs-results.json', JSON.stringify(results, null, 2));
                            
                            console.log(\`ðŸ’¾ Result saved to ipfs-results.json\`);
                            
                          } catch (error) {
                            console.error(\`âŒ Upload failed for \${relativePath}:\`, error.message);
                            console.error('Error details:', error);
                            process.exit(1);
                          }
                        }
                        
                        uploadFile().catch(error => {
                          console.error(\`âŒ Unexpected error during upload for \${relativePath}:\`, error.message);
                          process.exit(1);
                        });
                      "
                      
                      # Clean up temp file
                      rm -f "$temp_file"
                    else
                      echo "âŒ Temp file not found: $temp_file"
                    fi
                  else
                    echo "âŒ Content extraction failed for: $relative_path"
                  fi
                else
                  echo "âŒ File not found: $full_path"
                fi
              fi
            done
          fi

      - name: Display IPFS upload results
        run: |
          echo "## IPFS Upload Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**PR #${{ github.event.pull_request.number }}:** ${{ github.event.pull_request.title }}" >> $GITHUB_STEP_SUMMARY
          echo "**Author:** @${{ github.event.pull_request.user.login }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "ipfs-results.json" ]; then
            # Check if results file has content
            RESULT_COUNT=$(node -e "
              const fs = require('fs');
              try {
                const results = JSON.parse(fs.readFileSync('ipfs-results.json', 'utf8'));
                console.log(results.length);
              } catch (e) {
                console.log(0);
              }
            ")

            if [ "$RESULT_COUNT" -gt 0 ]; then
              echo "### ðŸŒ Successfully Uploaded to IPFS:" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**ðŸ“Š Total files uploaded:** $RESULT_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              # Generate detailed results
              node -e "
                const fs = require('fs');
                const results = JSON.parse(fs.readFileSync('ipfs-results.json', 'utf8'));
                
                results.forEach((result, index) => {
                  console.log(\`#### ðŸ“„ \${result.relativePath}\`);
                  console.log('');
                  console.log(\`- **IPFS Hash:** \\\`\${result.ipfsHash}\\\`\`);
                  console.log(\`- **Gateway URL:** [View on IPFS](https://gateway.pinata.cloud/ipfs/\${result.ipfsHash})\`);
                  console.log(\`- **File Size:** \${result.size} bytes\`);
                  console.log(\`- **Uploaded:** \${new Date(result.uploadedAt).toLocaleString()}\`);
                  console.log('');
                });
              " >> $GITHUB_STEP_SUMMARY
            else
              echo "âš ï¸ No files were successfully uploaded to IPFS." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âŒ No IPFS upload results found." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This may indicate an error during the upload process." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload IPFS results as artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ipfs-upload-results
          path: ipfs-results.json
          retention-days: 30

  create-eas-attestation:
    runs-on: ubuntu-latest
    needs: upload-to-ipfs
    if: needs.detect-evidence-changes.outputs.evidence-count > 0

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download IPFS results
        uses: actions/download-artifact@v4
        with:
          name: ipfs-upload-results
          path: .

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20.x.x"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: "10.x.x"

      - name: Install dependencies
        run: |
          pnpm install @ethereum-attestation-service/eas-sdk ethers dotenv gray-matter

      - name: Create EAS attestation
        env:
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
        run: |
          echo "ðŸ“ Creating EAS attestation for IPFS content"

          # Read IPFS results
          if [ -f "ipfs-results.json" ]; then
            node -e "
              const fs = require('fs');
              const { execSync } = require('child_process');
              const eas = require('./.github/scripts/eas.js');
              const path = require('path');
              
              async function createAttestations() {
                try {
                  const results = JSON.parse(fs.readFileSync('ipfs-results.json', 'utf8'));
                  const attestationResults = [];
                  
                  for (const result of results) {
                    console.log(\`Processing attestation for \${result.relativePath}\`);
                    
                    // Read the original MDX file to get frontmatter
                    const mdxPath = \`contents/evidence/\${result.relativePath}\`;
                    const mdxContent = fs.readFileSync(mdxPath, 'utf8');
                    
                    // Extract frontmatter using gray-matter
                    const matter = require('gray-matter');
                    const { data: frontmatter } = matter(mdxContent);
                    
                    // Get the latest attestation UID from deployment file if it exists
                    const evidenceId = path.basename(path.dirname(result.relativePath));
                    const deploymentPath = \`contents/deployments/\${evidenceId}.json\`;
                    let refUID = '';
                    
                    if (fs.existsSync(deploymentPath)) {
                      try {
                        const deploymentData = JSON.parse(fs.readFileSync(deploymentPath, 'utf8'));
                        if (deploymentData.attestationUID) {
                          refUID = deploymentData.attestationUID;
                          console.log(\`ðŸ“Ž Found previous attestation UID: \${refUID}\`);
                        }
                      } catch (error) {
                        console.warn(\`âš ï¸ Error reading deployment file: \${error.message}\`);
                      }
                    }
                    
                    // Prepare data object for EAS
                    const data = {
                      meta: frontmatter,
                      content: result.ipfsHash,
                      refUID: refUID
                    };
                    
                    // Create attestation
                    const attestationUID = await eas({ data });
                    console.log(\`âœ… Attestation created with UID: \${attestationUID}\`);
                    
                    // Store result for deployment file creation
                    attestationResults.push({
                      ...result,
                      attestationUID,
                      timestamp: new Date().toISOString()
                    });
                  }
                  
                  // Save attestation results for the next step
                  fs.writeFileSync('attestation-results.json', JSON.stringify(attestationResults, null, 2));
                  
                } catch (error) {
                  console.error('Error creating attestations:', error);
                  process.exit(1);
                }
              }
              
              createAttestations().catch(console.error);
            "
          else
            echo "âŒ No IPFS results found"
            exit 1
          fi

      - name: Create deployment files
        run: |
          echo "ðŸ“ Creating deployment files for attestations"

          if [ -f "attestation-results.json" ]; then
            node -e "
              const fs = require('fs');
              const path = require('path');
              
              try {
                const results = JSON.parse(fs.readFileSync('attestation-results.json', 'utf8'));
                
                for (const result of results) {
                  // Extract evidenceId from the relative path
                  const evidenceId = path.basename(path.dirname(result.relativePath));
                  
                  // Create deployment file path
                  const deploymentPath = \`contents/deployments/\${evidenceId}.json\`;
                  
                  // Read existing deployment data if it exists
                  let existingData = {};
                  if (fs.existsSync(deploymentPath)) {
                    try {
                      existingData = JSON.parse(fs.readFileSync(deploymentPath, 'utf8'));
                      console.log(\`ðŸ“„ Found existing deployment file: \${deploymentPath}\`);
                    } catch (error) {
                      console.warn(\`âš ï¸ Error reading existing deployment file: \${error.message}\`);
                    }
                  }
                  
                  // Create history entry from existing data if it exists
                  const history = existingData.history || [];
                  if (existingData.attestationUID) {
                    history.push({
                      ipfsHash: existingData.ipfsHash,
                      attestationUID: existingData.attestationUID,
                      timestamp: existingData.timestamp,
                      size: existingData.size
                    });
                  }
                  
                  // Create deployment data, preserving existing data
                  const deploymentData = {
                    ...existingData,
                    evidenceId,
                    ipfsHash: result.ipfsHash,
                    attestationUID: result.attestationUID,
                    timestamp: result.timestamp,
                    size: result.size,
                    updatedAt: new Date().toISOString(),
                    history: history
                  };
                  
                  // Ensure deployments directory exists
                  const deploymentsDir = path.dirname(deploymentPath);
                  if (!fs.existsSync(deploymentsDir)) {
                    fs.mkdirSync(deploymentsDir, { recursive: true });
                  }
                  
                  // Write deployment file
                  fs.writeFileSync(deploymentPath, JSON.stringify(deploymentData, null, 2));
                  console.log(\`âœ… \${fs.existsSync(deploymentPath) ? 'Updated' : 'Created'} deployment file: \${deploymentPath}\`);
                }
              } catch (error) {
                console.error('Error creating deployment files:', error);
                process.exit(1);
              }
            "
          else
            echo "âŒ No attestation results found"
            exit 1
          fi

      - name: Display EAS attestation results
        run: |
          echo "## EAS Attestation Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f "attestation-results.json" ]; then
            RESULT_COUNT=$(node -e "const fs = require('fs'); try { const results = JSON.parse(fs.readFileSync('attestation-results.json', 'utf8')); console.log(results.length); } catch (e) { console.log(0); }")
            if [ "$RESULT_COUNT" -gt 0 ]; then
              echo "### ðŸ›¡ï¸ Successfully Created EAS Attestations:" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**ðŸ“Š Total attestations:** $RESULT_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              node -e "const fs = require('fs'); const results = JSON.parse(fs.readFileSync('attestation-results.json', 'utf8')); results.forEach((result, index) => { console.log(`#### ðŸ“„ ${result.relativePath}`); console.log(''); console.log(`- **Attestation UID:** \`${result.attestationUID}\``); if(result.transactionHash) console.log(`- **Transaction Hash:** \`${result.transactionHash}\``); if(result.blockNumber) console.log(`- **Block Number:** ${result.blockNumber}`); console.log(`- **IPFS Hash:** \`${result.ipfsHash}\``); console.log(`- **File Size:** ${result.size} bytes`); console.log(`- **Attested:** ${new Date(result.timestamp).toLocaleString()}`); console.log(''); });" >> $GITHUB_STEP_SUMMARY
            else
              echo "âš ï¸ No attestations were created." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âŒ No EAS attestation results found." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This may indicate an error during the attestation process." >> $GITHUB_STEP_SUMMARY
          fi

      # TODO: enable below lines
      # - name: Commit and push deployment files
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   run: |
      #     git config --global user.name "GitHub Actions"
      #     git config --global user.email "actions@github.com"

      #     # Get the current branch name
      #     BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
      #     if [ "$BRANCH_NAME" = "HEAD" ]; then
      #       # If we're in detached HEAD state, use the target branch
      #       BRANCH_NAME="main"
      #     fi

      #     # Configure git to use the token
      #     git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git

      #     # Fetch the latest changes
      #     git fetch origin $BRANCH_NAME

      #     # Create a new branch from the latest state
      #     git checkout -b temp-branch origin/$BRANCH_NAME || git checkout temp-branch

      #     # Add and commit changes
      #     git add contents/deployments/
      #     git commit -m "chore(actions): add deployment files for evidence attestations" || echo "No changes to commit"

      #     # Push to the original branch
      #     git push origin temp-branch:$BRANCH_NAME
